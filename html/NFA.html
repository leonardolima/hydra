<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory NFA</title>
</head>


<body>
<div class="head">
<h1>Theory NFA</h1>
</div>

<pre class="source"><span class="keyword1"><span class="command">theory</span></span> NFA
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="../../HOL/HOL-Library/IArray.html">HOL-Library.IArray</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> state <span class="main">=</span> <span class="quoted">nat</span>

<span class="keyword1"><span class="command">datatype</span></span> transition <span class="main">=</span> cond_eps <span class="quoted">state</span> <span class="quoted">nat</span> <span class="main">|</span> wild_trans <span class="quoted">state</span> <span class="main">|</span> split_trans <span class="quoted">state</span> <span class="quoted">state</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">state_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"transition <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">state_set</span> <span class="main">(</span>cond_eps <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">state_set</span> <span class="main">(</span>wild_trans <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">state_set</span> <span class="main">(</span>split_trans <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">fmla_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"transition <span class="main">⇒</span> nat set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fmla_set</span> <span class="main">(</span>cond_eps <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">fmla_set</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rtranclp_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"rtranclp <span class="free">R</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">X</span> <span class="main">=</span> <span class="free">X</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">q'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">q</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">R</span> <span class="bound">q</span> <span class="bound">q'</span><span class="main">}</span> <span class="main">⟹</span>
  <span class="free">q</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">⟹</span> <span class="free">q'</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> rtranclp_closed_sub<span class="main">:</span> <span class="quoted"><span class="quoted">"rtranclp <span class="free">R</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="main">{</span><span class="bound">q'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">q</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">R</span> <span class="bound">q</span> <span class="bound">q'</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">X</span> <span class="main">⟹</span>
  <span class="free">q</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">⟹</span> <span class="free">q'</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> rtranclp_closed_sub'<span class="main">:</span> <span class="quoted"><span class="quoted">"rtranclp <span class="free">R</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q'</span> <span class="main">=</span> <span class="free">q</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">q''</span><span class="main">.</span> <span class="free">R</span> <span class="free">q</span> <span class="bound">q''</span> <span class="main">∧</span> rtranclp <span class="free">R</span> <span class="bound">q''</span> <span class="free">q'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> converse_rtranclpE <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">lemma</span></span> rtranclp_step<span class="main">:</span> <span class="quoted"><span class="quoted">"rtranclp <span class="free">R</span> <span class="free">q</span> <span class="free">q''</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">q'</span><span class="main">.</span> <span class="free">R</span> <span class="free">q</span> <span class="bound">q'</span> <span class="main">⟷</span> <span class="bound">q'</span> <span class="main">∈</span> <span class="free">X</span><span class="main">)</span> <span class="main">⟹</span>
  <span class="free">q</span> <span class="main">=</span> <span class="free">q''</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">q'</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">R</span> <span class="free">q</span> <span class="bound">q'</span> <span class="main">∧</span> rtranclp <span class="free">R</span> <span class="bound">q'</span> <span class="free">q''</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q''</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtranclp.rtrancl_into_rtrancl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rtranclp_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"rtranclp <span class="free">R</span> <span class="free">x</span> <span class="free">z</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">z</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">R</span> <span class="free">x</span> <span class="bound">y</span> <span class="main">∧</span> rtranclp <span class="free">R</span> <span class="bound">y</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">z</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span>
  <span class="free">q0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="free">qf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="free">transs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"transition list"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* sets of states *)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">SQ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">SQ</span> <span class="main">=</span> <span class="main">{</span><span class="free">q0</span><span class="main">..&lt;</span><span class="free">q0</span> <span class="main">+</span> length <span class="free">transs</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> q_in_SQ<span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> SQ <span class="main">⟷</span> <span class="free">q0</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">∧</span> <span class="free">q</span> <span class="main">&lt;</span> <span class="free">q0</span> <span class="main">+</span> length <span class="free">transs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> SQ_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_SQ<span class="main">:</span> <span class="quoted"><span class="quoted">"finite SQ"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SQ_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> transs_q_in_set<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> SQ <span class="main">⟹</span> <span class="free">transs</span> <span class="main">!</span> <span class="main">(</span><span class="free">q</span> <span class="main">-</span> <span class="free">q0</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">transs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SQ_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">Q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">=</span> SQ <span class="main">∪</span> <span class="main">{</span><span class="free">qf</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"finite Q"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Q_def SQ_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> SQ_sub_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"SQ <span class="main">⊆</span> Q"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SQ_def Q_def<span class="main">)</span>

<span class="comment1">(* set of formula indices *)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">nfa_fmla_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nfa_fmla_set</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>fmla_set <span class="main">`</span> set <span class="free">transs</span><span class="main">)</span>"</span></span>

<span class="comment1">(* step relation *)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_eps</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool list <span class="main">⇒</span> state <span class="main">⇒</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_eps</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">∈</span> SQ <span class="main">∧</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">transs</span> <span class="main">!</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">-</span> <span class="free">q0</span><span class="main">)</span> <span class="keyword1">of</span> cond_eps <span class="bound">p</span> <span class="bound">n</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">!</span> <span class="bound">n</span> <span class="main">∧</span> <span class="bound">p</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span>
    <span class="main">|</span> split_trans <span class="bound">p</span> <span class="bound">p'</span> <span class="main">⇒</span> <span class="bound">p</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span> <span class="main">∨</span> <span class="bound">p'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_dest<span class="main">:</span> <span class="quoted"><span class="quoted">"step_eps <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> SQ"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_eps_def<span class="main">)</span>

<span class="comment1">(* successors in step relation *)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_eps_sucs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool list <span class="main">⇒</span> state <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_eps_sucs</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">∈</span> SQ <span class="keyword1">then</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">transs</span> <span class="main">!</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">-</span> <span class="free">q0</span><span class="main">)</span> <span class="keyword1">of</span> cond_eps <span class="bound">p</span> <span class="bound">n</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">!</span> <span class="bound">n</span> <span class="keyword1">then</span> <span class="main">{</span><span class="bound">p</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span>
    <span class="main">|</span> split_trans <span class="bound">p</span> <span class="bound">p'</span> <span class="main">⇒</span> <span class="main">{</span><span class="bound">p</span><span class="main">,</span> <span class="bound">p'</span><span class="main">}</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">{}</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_sucs_sound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q'</span> <span class="main">∈</span> step_eps_sucs <span class="free">bs</span> <span class="free">q</span> <span class="main">⟷</span> step_eps <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_eps_sucs_def step_eps_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> transition.splits<span class="main">)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_eps_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool list <span class="main">⇒</span> state set <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_eps_set</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>step_eps_sucs <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_set_sound<span class="main">:</span> <span class="quoted"><span class="quoted">"step_eps_set <span class="free">bs</span> <span class="free">R</span> <span class="main">=</span> <span class="main">{</span><span class="bound">q'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">q</span> <span class="main">∈</span> <span class="free">R</span><span class="main">.</span> step_eps <span class="free">bs</span> <span class="bound">q</span> <span class="bound">q'</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> step_eps_sucs_sound <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_eps_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_set_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> <span class="free">S</span> <span class="main">⟹</span> step_eps_set <span class="free">bs</span> <span class="free">R</span> <span class="main">⊆</span> step_eps_set <span class="free">bs</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_eps_set_def<span class="main">)</span>

<span class="comment1">(* reflexive and transitive closure of step relation *)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">eps_closure</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool list <span class="main">⇒</span> state <span class="main">⇒</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eps_closure</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> <span class="main">(</span>step_eps <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_dest<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">≠</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> SQ"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> eps_closure_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> step_eps_dest <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">eps_closure_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set <span class="main">⇒</span> bool list <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eps_closure_set</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> <span class="main">{</span><span class="bound">q'</span><span class="main">.</span> eps_closure <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="bound">q</span> <span class="bound">q'</span><span class="main">}</span><span class="main">)</span> <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> eps_closure_set <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eps_closure_set_def eps_closure_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> <span class="free">S</span> <span class="main">⟹</span> eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">⊆</span> eps_closure_set <span class="free">S</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eps_closure_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="main">{}</span> <span class="free">bs</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eps_closure_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_split<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">S</span><span class="main">)</span> <span class="free">bs</span> <span class="main">=</span>
  eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">∪</span> eps_closure_set <span class="free">S</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eps_closure_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span><span class="main">)</span> <span class="free">bs</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> eps_closure_set <span class="main">(</span><span class="free">R</span> <span class="bound">x</span><span class="main">)</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eps_closure_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_idem<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="main">(</span>eps_closure_set <span class="free">R</span> <span class="free">bs</span><span class="main">)</span> <span class="free">bs</span> <span class="main">=</span>
  eps_closure_set <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> eps_closure_set_def eps_closure_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_flip<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">R</span> <span class="main">∪</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="free">S</span> <span class="free">bs</span> <span class="main">⊆</span> <span class="free">R</span> <span class="main">∪</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eps_closure_set_idem<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">R</span></span> <span class="quoted"><span class="free">bs</span></span><span class="main">,</span> <span class="operator">unfolded</span> assms<span class="main">,</span> <span class="operator">unfolded</span> eps_closure_set_split<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">q'</span><span class="main">.</span> step_eps <span class="free">bs</span> <span class="free">q</span> <span class="bound">q'</span> <span class="main">⟷</span> <span class="bound">q'</span> <span class="main">∈</span> <span class="free">X</span><span class="main">)</span> <span class="main">⟹</span>
  eps_closure_set <span class="main">{</span><span class="free">q</span><span class="main">}</span> <span class="free">bs</span> <span class="main">=</span> <span class="main">{</span><span class="free">q</span><span class="main">}</span> <span class="main">∪</span> eps_closure_set <span class="free">X</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> eps_closure_set_def eps_closure_def
  <span class="keyword1"><span class="command">using</span></span> rtranclp_step<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"step_eps <span class="free">bs</span>"</span></span> <span class="quoted"><span class="free">q</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> converse_rtranclp_into_rtranclp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_closure<span class="main">:</span> <span class="quoted"><span class="quoted">"step_eps <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="free">q'</span> <span class="main">∈</span> eps_closure_set <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> eps_closure_set_def eps_closure_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">let</span> <span class="bound">R'</span> <span class="main">=</span> <span class="free">R</span> <span class="main">∪</span> step_eps_set <span class="free">bs</span> <span class="free">R</span> <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="free">R</span> <span class="main">=</span> <span class="bound">R'</span> <span class="keyword1">then</span> <span class="free">R</span> <span class="keyword1">else</span> eps_closure_set <span class="bound">R'</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> rtranclp_closed
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eps_closure_set_def eps_closure_def step_eps_set_sound Let_def<span class="main">)</span>

<span class="comment1">(* wildcard step relation *)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_wild</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state <span class="main">⇒</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_wild</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">∈</span> SQ <span class="main">∧</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">transs</span> <span class="main">!</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">-</span> <span class="free">q0</span><span class="main">)</span> <span class="keyword1">of</span> wild_trans <span class="bound">p</span> <span class="main">⇒</span> <span class="bound">p</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_dest<span class="main">:</span> <span class="quoted"><span class="quoted">"step_wild <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> SQ"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_wild_def<span class="main">)</span>

<span class="comment1">(* successors in wildcard step relation *)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_wild_sucs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_wild_sucs</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">∈</span> SQ <span class="keyword1">then</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">transs</span> <span class="main">!</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">-</span> <span class="free">q0</span><span class="main">)</span> <span class="keyword1">of</span> wild_trans <span class="bound">p</span> <span class="main">⇒</span> <span class="main">{</span><span class="bound">p</span><span class="main">}</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">{}</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_sucs_sound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q'</span> <span class="main">∈</span> step_wild_sucs <span class="free">q</span> <span class="main">⟷</span> step_wild <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_wild_sucs_def step_wild_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> transition.splits<span class="main">)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_wild_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_wild_set</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">q'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">q</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">.</span> step_wild <span class="bound">q</span> <span class="bound">q'</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> <span class="free">S</span> <span class="main">⟹</span> step_wild_set <span class="free">R</span> <span class="main">⊆</span> step_wild_set <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_wild_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"step_wild_set <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_wild_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_proj<span class="main">:</span> <span class="quoted"><span class="quoted">"step_wild_set <span class="free">R</span> <span class="main">=</span> step_wild_set <span class="main">(</span><span class="free">R</span> <span class="main">∩</span> SQ<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> step_wild_dest <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_wild_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_split<span class="main">:</span> <span class="quoted"><span class="quoted">"step_wild_set <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">S</span><span class="main">)</span> <span class="main">=</span> step_wild_set <span class="free">R</span> <span class="main">∪</span> step_wild_set <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_wild_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"step_wild_set <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> step_wild_set <span class="main">(</span><span class="free">R</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_wild_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"step_wild_set <span class="free">R</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>step_wild_sucs <span class="main">`</span> <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> step_wild_sucs_sound <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_wild_set_def<span class="main">)</span>

<span class="comment1">(* delta function *)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">delta</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set <span class="main">⇒</span> bool list <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">delta</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> step_wild_set <span class="main">(</span>eps_closure_set <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> delta_eps<span class="main">:</span> <span class="quoted"><span class="quoted">"delta <span class="main">(</span>eps_closure_set <span class="free">R</span> <span class="free">bs</span><span class="main">)</span> <span class="free">bs</span> <span class="main">=</span> delta <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> delta_def eps_closure_set_idem <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> delta_eps_split<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">R</span> <span class="main">∪</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"delta <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> step_wild_set <span class="free">R</span> <span class="main">∪</span> delta <span class="free">S</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> delta_def assms step_wild_set_split
  <span class="keyword1"><span class="command">using</span></span> step_wild_set_mono<span class="main">[</span><span class="operator">OF</span> eps_closure_set_flip<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">unfolded</span> step_wild_set_split<span class="main">]</span>
    step_wild_set_mono<span class="main">[</span><span class="operator">OF</span> eps_closure_set_refl<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> delta_split<span class="main">:</span> <span class="quoted"><span class="quoted">"delta <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">S</span><span class="main">)</span> <span class="free">bs</span> <span class="main">=</span> delta <span class="free">R</span> <span class="free">bs</span> <span class="main">∪</span> delta <span class="free">S</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> delta_def step_wild_set_split eps_closure_set_split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> delta_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"delta <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span><span class="main">)</span> <span class="free">bs</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> delta <span class="main">(</span><span class="free">R</span> <span class="bound">x</span><span class="main">)</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> delta_def eps_closure_set_Un step_wild_set_Un <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> delta_step_wild_set_absorb<span class="main">:</span> <span class="quoted"><span class="quoted">"delta <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> delta <span class="free">R</span> <span class="free">bs</span> <span class="main">∪</span> step_wild_set <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eps_closure_set_refl <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> delta_def step_wild_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> delta_sub_eps_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">⊆</span> eps_closure_set <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"delta <span class="free">S</span> <span class="free">bs</span> <span class="main">⊆</span> delta <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> delta_def
  <span class="keyword1"><span class="command">using</span></span> step_wild_set_mono<span class="main">[</span><span class="operator">OF</span> eps_closure_set_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="quoted"><span class="free">bs</span></span><span class="main"><span class="main">,</span></span>
        <span class="operator">unfolded</span> eps_closure_set_idem<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* run delta function *)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">run</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set <span class="main">⇒</span> bool list list <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">run</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bss</span></span></span> <span class="main">=</span> foldl delta <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bss</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> run_eps_split<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">R</span> <span class="main">∪</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"step_wild_set <span class="free">R</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"run <span class="free">R</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span> <span class="main">=</span> run <span class="free">S</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_def foldl.simps delta_eps_split<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">unfolded</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> run_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"run <span class="main">{}</span> <span class="free">bss</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">bss</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> delta_def step_wild_set_empty eps_closure_set_empty<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"run <span class="free">R</span> <span class="main">[]</span> <span class="main">=</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"run <span class="free">R</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span> <span class="main">=</span> run <span class="main">(</span>delta <span class="free">R</span> <span class="free">bs</span><span class="main">)</span> <span class="free">bss</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> run_split<span class="main">:</span> <span class="quoted"><span class="quoted">"run <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">S</span><span class="main">)</span> <span class="free">bss</span> <span class="main">=</span> run <span class="free">R</span> <span class="free">bss</span> <span class="main">∪</span> run <span class="free">S</span> <span class="free">bss</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">bss</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">R</span></span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> delta_split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"run <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span><span class="main">)</span> <span class="free">bss</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> run <span class="main">(</span><span class="free">R</span> <span class="bound">x</span><span class="main">)</span> <span class="free">bss</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">bss</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">R</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> delta_Un<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"run <span class="free">R</span> <span class="main">(</span><span class="free">bss</span> <span class="main">@</span> <span class="free">css</span><span class="main">)</span> <span class="main">=</span> run <span class="main">(</span>run <span class="free">R</span> <span class="free">bss</span><span class="main">)</span> <span class="free">css</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* accept function *)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">accept</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set <span class="main">⇒</span> bool list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">accept</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="free">qf</span> <span class="main">∈</span> eps_closure_set <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_accept<span class="main">:</span> <span class="quoted"><span class="quoted">"step_eps <span class="free">bs</span> <span class="free">q</span> <span class="free">qf</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> accept <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> accept_def <span class="keyword1"><span class="command">using</span></span> step_eps_closure <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> accept_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"accept <span class="main">{}</span> <span class="free">bs</span> <span class="main">⟷</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> accept_def eps_closure_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> accept_split<span class="main">:</span> <span class="quoted"><span class="quoted">"accept <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">S</span><span class="main">)</span> <span class="free">bs</span> <span class="main">⟷</span> accept <span class="free">R</span> <span class="free">bs</span> <span class="main">∨</span> accept <span class="free">S</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> accept_def eps_closure_set_split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> accept_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"accept <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span><span class="main">)</span> <span class="free">bs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> accept <span class="main">(</span><span class="free">R</span> <span class="bound">x</span><span class="main">)</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> accept_def eps_closure_set_def<span class="main">)</span>

<span class="comment1">(* is a run accepting? *)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">run_accept</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set <span class="main">⇒</span> bool list list <span class="main">⇒</span> bool list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">run_accept</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bss</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> accept <span class="main">(</span>run <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bss</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>run_accept <span class="main">{}</span> <span class="free">bss</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_accept_def run_empty accept_empty <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"run_accept <span class="free">R</span> <span class="main">[]</span> <span class="free">cs</span> <span class="main">⟷</span> accept <span class="free">R</span> <span class="free">cs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_accept_def run_Nil<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"run_accept <span class="free">R</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span> <span class="free">cs</span> <span class="main">⟷</span> run_accept <span class="main">(</span>delta <span class="free">R</span> <span class="free">bs</span><span class="main">)</span> <span class="free">bss</span> <span class="free">cs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_accept_def run_Cons<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_Cons_delta_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"delta <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> delta <span class="free">S</span> <span class="free">bs</span> <span class="main">⟹</span>
  run_accept <span class="free">R</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span> <span class="free">cs</span> <span class="main">⟷</span> run_accept <span class="free">S</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span> <span class="free">cs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_accept_Cons <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_Nil_eps<span class="main">:</span> <span class="quoted"><span class="quoted">"run_accept <span class="main">(</span>eps_closure_set <span class="free">R</span> <span class="free">bs</span><span class="main">)</span> <span class="main">[]</span> <span class="free">bs</span> <span class="main">⟷</span> run_accept <span class="free">R</span> <span class="main">[]</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_accept_Nil accept_def eps_closure_set_idem <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_Cons_eps<span class="main">:</span> <span class="quoted"><span class="quoted">"run_accept <span class="main">(</span>eps_closure_set <span class="free">R</span> <span class="free">cs</span><span class="main">)</span> <span class="main">(</span><span class="free">cs</span> <span class="main">#</span> <span class="free">css</span><span class="main">)</span> <span class="free">bs</span> <span class="main">⟷</span>
  run_accept <span class="free">R</span> <span class="main">(</span><span class="free">cs</span> <span class="main">#</span> <span class="free">css</span><span class="main">)</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_accept_Cons delta_eps <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_Nil_eps_split<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">R</span> <span class="main">∪</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"step_wild_set <span class="free">R</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">qf</span> <span class="main">∉</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"run_accept <span class="free">R</span> <span class="main">[]</span> <span class="free">bs</span> <span class="main">=</span> run_accept <span class="free">S</span> <span class="main">[]</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Nil run_accept_Nil accept_def assms<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> eps_closure_set_refl eps_closure_set_flip<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_Cons_eps_split<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="free">R</span> <span class="free">cs</span> <span class="main">=</span> <span class="free">R</span> <span class="main">∪</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"step_wild_set <span class="free">R</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">qf</span> <span class="main">∉</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"run_accept <span class="free">R</span> <span class="main">(</span><span class="free">cs</span> <span class="main">#</span> <span class="free">css</span><span class="main">)</span> <span class="free">bs</span> <span class="main">=</span> run_accept <span class="free">S</span> <span class="main">(</span><span class="free">cs</span> <span class="main">#</span> <span class="free">css</span><span class="main">)</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_accept_def Cons run_eps_split<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_split<span class="main">:</span> <span class="quoted"><span class="quoted">"run_accept <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">S</span><span class="main">)</span> <span class="free">bss</span> <span class="free">bs</span> <span class="main">⟷</span>
  run_accept <span class="free">R</span> <span class="free">bss</span> <span class="free">bs</span> <span class="main">∨</span> run_accept <span class="free">S</span> <span class="free">bss</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_accept_def run_split accept_split <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"run_accept <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span><span class="main">)</span> <span class="free">bss</span> <span class="free">bs</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> run_accept <span class="main">(</span><span class="free">R</span> <span class="bound">x</span><span class="main">)</span> <span class="free">bss</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_accept_def run_Un accept_Un <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* no step_eps *)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">q'</span><span class="main">.</span> <span class="main">¬</span>step_eps <span class="free">bs</span> <span class="free">q</span> <span class="bound">q'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">=</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> eps_closure_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_step_id<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">q</span> <span class="bound">q'</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="main">¬</span>step_eps <span class="free">bs</span> <span class="bound">q</span> <span class="bound">q'</span><span class="main">)</span> <span class="main">⟹</span>
  eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eps_closure_empty eps_closure_set_refl <span class="keyword1"><span class="command">unfolding</span></span> eps_closure_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span>
  <span class="free">transs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"transition iarray"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">len</span> <span class="main">::</span> <span class="quoted">nat</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_eps'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool iarray <span class="main">⇒</span> state <span class="main">⇒</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_eps'</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">&lt;</span> <span class="free">len</span> <span class="main">∧</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">transs</span> <span class="main">!!</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="keyword1">of</span> cond_eps <span class="bound">p</span> <span class="bound">n</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">!!</span> <span class="bound">n</span> <span class="main">∧</span> <span class="bound">p</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span>
    <span class="main">|</span> split_trans <span class="bound">p</span> <span class="bound">p'</span> <span class="main">⇒</span> <span class="bound">p</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span> <span class="main">∨</span> <span class="bound">p'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">eps_closure'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool iarray <span class="main">⇒</span> state <span class="main">⇒</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eps_closure'</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> <span class="main">(</span>step_eps' <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_eps_sucs'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool iarray <span class="main">⇒</span> state <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_eps_sucs'</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">&lt;</span> <span class="free">len</span> <span class="keyword1">then</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">transs</span> <span class="main">!!</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="keyword1">of</span> cond_eps <span class="bound">p</span> <span class="bound">n</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">!!</span> <span class="bound">n</span> <span class="keyword1">then</span> <span class="main">{</span><span class="bound">p</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span>
    <span class="main">|</span> split_trans <span class="bound">p</span> <span class="bound">p'</span> <span class="main">⇒</span> <span class="main">{</span><span class="bound">p</span><span class="main">,</span> <span class="bound">p'</span><span class="main">}</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">{}</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_sucs'_sound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q'</span> <span class="main">∈</span> step_eps_sucs' <span class="free">bs</span> <span class="free">q</span> <span class="main">⟷</span> step_eps' <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_eps_sucs'_def step_eps'_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> transition.splits<span class="main">)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_eps_set'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool iarray <span class="main">⇒</span> state set <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_eps_set'</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>step_eps_sucs' <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_set'_sound<span class="main">:</span> <span class="quoted"><span class="quoted">"step_eps_set' <span class="free">bs</span> <span class="free">R</span> <span class="main">=</span> <span class="main">{</span><span class="bound">q'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">q</span> <span class="main">∈</span> <span class="free">R</span><span class="main">.</span> step_eps' <span class="free">bs</span> <span class="bound">q</span> <span class="bound">q'</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> step_eps_sucs'_sound <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_eps_set'_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">eps_closure_set'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set <span class="main">⇒</span> bool iarray <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eps_closure_set'</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> <span class="main">{</span><span class="bound">q'</span><span class="main">.</span> eps_closure' <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="bound">q</span> <span class="bound">q'</span><span class="main">}</span><span class="main">)</span> <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set'_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"eps_closure_set' <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">let</span> <span class="bound">R'</span> <span class="main">=</span> <span class="free">R</span> <span class="main">∪</span> step_eps_set' <span class="free">bs</span> <span class="free">R</span> <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="free">R</span> <span class="main">=</span> <span class="bound">R'</span> <span class="keyword1">then</span> <span class="free">R</span> <span class="keyword1">else</span> eps_closure_set' <span class="bound">R'</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> rtranclp_closed
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eps_closure_set'_def eps_closure'_def step_eps_set'_sound Let_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_wild_sucs'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_wild_sucs'</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">&lt;</span> <span class="free">len</span> <span class="keyword1">then</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">transs</span> <span class="main">!!</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="keyword1">of</span> wild_trans <span class="bound">p</span> <span class="main">⇒</span> <span class="main">{</span><span class="bound">p</span><span class="main">}</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">{}</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">step_wild_set'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step_wild_set'</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>step_wild_sucs' <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">delta'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set <span class="main">⇒</span> bool iarray <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">delta'</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> step_wild_set' <span class="main">(</span>eps_closure_set' <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">accept'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set <span class="main">⇒</span> bool iarray <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">accept'</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="free">len</span> <span class="main">∈</span> eps_closure_set' <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">run'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set <span class="main">⇒</span> bool iarray list <span class="main">⇒</span> state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">run'</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bss</span></span></span> <span class="main">=</span> foldl delta' <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bss</span></span></span>"</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">run_accept'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set <span class="main">⇒</span> bool iarray list <span class="main">⇒</span> bool iarray <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">run_accept'</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bss</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> accept' <span class="main">(</span>run' <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">bss</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> nfa_array <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">transs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"transition list"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">transs'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"transition iarray"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">len</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> transs_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">transs'</span> <span class="main">=</span> IArray <span class="free">transs</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> len_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">len</span> <span class="main">=</span> length <span class="free">transs</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_eps</span> <span class="main">≡</span> NFA.step_eps <span class="main">0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_eps'</span> <span class="main">≡</span> NFA.step_eps' <span class="free">transs'</span> <span class="free">len</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">eps_closure</span> <span class="main">≡</span> NFA.eps_closure <span class="main">0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">eps_closure'</span> <span class="main">≡</span> NFA.eps_closure' <span class="free">transs'</span> <span class="free">len</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_eps_sucs</span> <span class="main">≡</span> NFA.step_eps_sucs <span class="main">0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_eps_sucs'</span> <span class="main">≡</span> NFA.step_eps_sucs' <span class="free">transs'</span> <span class="free">len</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_eps_set</span> <span class="main">≡</span> NFA.step_eps_set <span class="main">0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_eps_set'</span> <span class="main">≡</span> NFA.step_eps_set' <span class="free">transs'</span> <span class="free">len</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">eps_closure_set</span> <span class="main">≡</span> NFA.eps_closure_set <span class="main">0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">eps_closure_set'</span> <span class="main">≡</span> NFA.eps_closure_set' <span class="free">transs'</span> <span class="free">len</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_wild_sucs</span> <span class="main">≡</span> NFA.step_wild_sucs <span class="main">0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_wild_sucs'</span> <span class="main">≡</span> NFA.step_wild_sucs' <span class="free">transs'</span> <span class="free">len</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_wild_set</span> <span class="main">≡</span> NFA.step_wild_set <span class="main">0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_wild_set'</span> <span class="main">≡</span> NFA.step_wild_set' <span class="free">transs'</span> <span class="free">len</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">delta</span> <span class="main">≡</span> NFA.delta <span class="main">0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">delta'</span> <span class="main">≡</span> NFA.delta' <span class="free">transs'</span> <span class="free">len</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">accept</span> <span class="main">≡</span> NFA.accept <span class="main">0</span> <span class="free">len</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">accept'</span> <span class="main">≡</span> NFA.accept' <span class="free">transs'</span> <span class="free">len</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">run</span> <span class="main">≡</span> NFA.run <span class="main">0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">run'</span> <span class="main">≡</span> NFA.run' <span class="free">transs'</span> <span class="free">len</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">run_accept</span> <span class="main">≡</span> NFA.run_accept <span class="main">0</span> <span class="free">len</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">run_accept'</span> <span class="main">≡</span> NFA.run_accept' <span class="free">transs'</span> <span class="free">len</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> q_in_SQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> NFA.SQ <span class="main">0</span> <span class="free">transs</span> <span class="main">⟷</span> <span class="free">q</span> <span class="main">&lt;</span> <span class="free">len</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> len_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFA.SQ_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs'</span> <span class="main">=</span> IArray <span class="free">bs</span> <span class="main">⟹</span> step_eps <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟷</span> step_eps' <span class="free">bs'</span> <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFA.step_eps_def NFA.step_eps'_def q_in_SQ transs_eq <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> transition.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs'</span> <span class="main">=</span> IArray <span class="free">bs</span> <span class="main">⟹</span> eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟷</span> eps_closure' <span class="free">bs'</span> <span class="free">q</span> <span class="free">q'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> lassm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs'</span> <span class="main">=</span> IArray <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> step_eps_eq_folded<span class="main">:</span> <span class="quoted"><span class="quoted">"step_eps <span class="free">bs</span> <span class="main">=</span> step_eps' <span class="free">bs'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> step_eps'_eq<span class="main">[</span><span class="operator">OF</span> lassm<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFA.eps_closure_def NFA.eps_closure'_def step_eps_eq_folded<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_sucs'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs'</span> <span class="main">=</span> IArray <span class="free">bs</span> <span class="main">⟹</span> step_eps_sucs <span class="free">bs</span> <span class="free">q</span> <span class="main">=</span> step_eps_sucs' <span class="free">bs'</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFA.step_eps_sucs_def NFA.step_eps_sucs'_def q_in_SQ transs_eq
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> transition.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_set'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs'</span> <span class="main">=</span> IArray <span class="free">bs</span> <span class="main">⟹</span> step_eps_set <span class="free">bs</span> <span class="free">R</span> <span class="main">=</span> step_eps_set' <span class="free">bs'</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFA.step_eps_set_def NFA.step_eps_set'_def step_eps_sucs'_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs'</span> <span class="main">=</span> IArray <span class="free">bs</span> <span class="main">⟹</span> eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> eps_closure_set' <span class="free">R</span> <span class="free">bs'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFA.eps_closure_set_def NFA.eps_closure_set'_def eps_closure'_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_sucs'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs'</span> <span class="main">=</span> IArray <span class="free">bs</span> <span class="main">⟹</span> step_wild_sucs <span class="free">R</span> <span class="main">=</span> step_wild_sucs' <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFA.step_wild_sucs_def NFA.step_wild_sucs'_def q_in_SQ transs_eq
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> transition.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs'</span> <span class="main">=</span> IArray <span class="free">bs</span> <span class="main">⟹</span> step_wild_set <span class="free">R</span> <span class="main">=</span> step_wild_set' <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> step_wild_set_code NFA.step_wild_set'_def step_wild_sucs'_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> delta'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs'</span> <span class="main">=</span> IArray <span class="free">bs</span> <span class="main">⟹</span> delta <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> delta' <span class="free">R</span> <span class="free">bs'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFA.delta_def NFA.delta'_def eps_closure_set'_eq step_wild_set'_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> accept'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs'</span> <span class="main">=</span> IArray <span class="free">bs</span> <span class="main">⟹</span> accept <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> accept' <span class="free">R</span> <span class="free">bs'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFA.accept_def NFA.accept'_def eps_closure_set'_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bss'</span> <span class="main">=</span> map IArray <span class="free">bss</span> <span class="main">⟹</span> run <span class="free">R</span> <span class="free">bss</span> <span class="main">=</span> run' <span class="free">R</span> <span class="free">bss'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">bss</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">R</span></span> <span class="quoted"><span class="free">bss'</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFA.run_def NFA.run'_def delta'_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bss'</span> <span class="main">=</span> map IArray <span class="free">bss</span> <span class="main">⟹</span> <span class="free">bs'</span> <span class="main">=</span> IArray <span class="free">bs</span> <span class="main">⟹</span>
  run_accept <span class="free">R</span> <span class="free">bss</span> <span class="free">bs</span> <span class="main">⟷</span> run_accept' <span class="free">R</span> <span class="free">bss'</span> <span class="free">bs'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFA.run_accept_def NFA.run_accept'_def accept'_eq run'_eq<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> nfa <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">q0</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">qf</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">transs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"transition list"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> state_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">t</span><span class="main">.</span> <span class="bound">t</span> <span class="main">∈</span> set <span class="free">transs</span> <span class="main">⟹</span> state_set <span class="bound">t</span> <span class="main">⊆</span> NFA.Q <span class="free">q0</span> <span class="free">qf</span> <span class="free">transs</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> transs_not_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">transs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> qf_not_in_SQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">qf</span> <span class="main">∉</span> NFA.SQ <span class="free">q0</span> <span class="free">transs</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">SQ</span> <span class="main">≡</span> NFA.SQ <span class="free">q0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">≡</span> NFA.Q <span class="free">q0</span> <span class="free">qf</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">nfa_fmla_set</span> <span class="main">≡</span> NFA.nfa_fmla_set <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_eps</span> <span class="main">≡</span> NFA.step_eps <span class="free">q0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_eps_sucs</span> <span class="main">≡</span> NFA.step_eps_sucs <span class="free">q0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_eps_set</span> <span class="main">≡</span> NFA.step_eps_set <span class="free">q0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">eps_closure</span> <span class="main">≡</span> NFA.eps_closure <span class="free">q0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">eps_closure_set</span> <span class="main">≡</span> NFA.eps_closure_set <span class="free">q0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_wild</span> <span class="main">≡</span> NFA.step_wild <span class="free">q0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_wild_sucs</span> <span class="main">≡</span> NFA.step_wild_sucs <span class="free">q0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">step_wild_set</span> <span class="main">≡</span> NFA.step_wild_set <span class="free">q0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">delta</span> <span class="main">≡</span> NFA.delta <span class="free">q0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">run</span> <span class="main">≡</span> NFA.run <span class="free">q0</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">accept</span> <span class="main">≡</span> NFA.accept <span class="free">q0</span> <span class="free">qf</span> <span class="free">transs</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">run_accept</span> <span class="main">≡</span> NFA.run_accept <span class="free">q0</span> <span class="free">qf</span> <span class="free">transs</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Q_diff_qf_SQ<span class="main">:</span> <span class="quoted"><span class="quoted">"Q <span class="main">-</span> <span class="main">{</span><span class="free">qf</span><span class="main">}</span> <span class="main">=</span> SQ"</span></span>
  <span class="keyword1"><span class="command">using</span></span> qf_not_in_SQ <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.Q_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> q0_sub_SQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">q0</span><span class="main">}</span> <span class="main">⊆</span> SQ"</span></span>
  <span class="keyword1"><span class="command">using</span></span> transs_not_Nil <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.SQ_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> q0_sub_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">q0</span><span class="main">}</span> <span class="main">⊆</span> Q"</span></span>
  <span class="keyword1"><span class="command">using</span></span> q0_sub_SQ SQ_sub_Q <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"step_eps <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q'</span> <span class="main">∈</span> Q"</span></span>
  <span class="keyword1"><span class="command">using</span></span> transs_q_in_set state_closed
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.step_eps_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> transition.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_set_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"step_eps_set <span class="free">bs</span> <span class="free">R</span> <span class="main">⊆</span> Q"</span></span>
  <span class="keyword1"><span class="command">using</span></span> step_eps_closed <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_eps_set_sound<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">≠</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q'</span> <span class="main">∈</span> Q"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> step_eps_closed <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_closed_union<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">⊆</span> <span class="free">R</span> <span class="main">∪</span> Q"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eps_closure_closed <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.eps_closure_set_def NFA.eps_closure_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> Q <span class="main">⟹</span> eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">⊆</span> Q"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eps_closure_set_closed_union <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"step_wild <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q'</span> <span class="main">∈</span> Q"</span></span>
  <span class="keyword1"><span class="command">using</span></span> transs_q_in_set state_closed
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.step_wild_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> transition.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"step_wild_set <span class="free">R</span> <span class="main">⊆</span> Q"</span></span>
  <span class="keyword1"><span class="command">using</span></span> step_wild_closed <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.step_wild_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_qf<span class="main">:</span> <span class="quoted"><span class="quoted">"step_wild_set <span class="main">{</span><span class="free">qf</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> qf_not_in_SQ step_wild_set_proj<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">qf</span><span class="main">}</span>"</span></span><span class="main">]</span> step_wild_set_empty <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> delta_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"delta <span class="free">R</span> <span class="free">bs</span> <span class="main">⊆</span> Q"</span></span>
  <span class="keyword1"><span class="command">using</span></span> step_wild_set_closed <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.delta_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_closed_Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"run <span class="free">R</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span> <span class="main">⊆</span> Q"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.run_def
  <span class="keyword1"><span class="command">using</span></span> delta_closed <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">bss</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">R</span></span> <span class="quoted"><span class="free">bs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> run_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> Q <span class="main">⟹</span> run <span class="free">R</span> <span class="free">bss</span> <span class="main">⊆</span> Q"</span></span>
  <span class="keyword1"><span class="command">using</span></span> run_Nil run_closed_Cons <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">bss</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="comment1">(* transitions from accepting state *)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_qf<span class="main">:</span> <span class="quoted"><span class="quoted">"step_eps <span class="free">bs</span> <span class="free">qf</span> <span class="free">q</span> <span class="main">⟷</span> False"</span></span>
  <span class="keyword1"><span class="command">using</span></span> qf_not_in_SQ step_eps_dest <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_qf<span class="main">:</span> <span class="quoted"><span class="quoted">"step_wild <span class="free">qf</span> <span class="free">q</span> <span class="main">⟷</span> False"</span></span>
  <span class="keyword1"><span class="command">using</span></span> qf_not_in_SQ step_wild_dest <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_qf<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">=</span> <span class="free">qf</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">=</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> step_eps_qf <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_qf<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="main">{</span><span class="free">qf</span><span class="main">}</span> <span class="free">bs</span> <span class="main">=</span> <span class="main">{</span><span class="free">qf</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eps_closure_qf <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_set_def NFA.eps_closure_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> delta_qf<span class="main">:</span> <span class="quoted"><span class="quoted">"delta <span class="main">{</span><span class="free">qf</span><span class="main">}</span> <span class="free">bs</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eps_closure_qf step_wild_qf
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.delta_def NFA.step_wild_set_def NFA.eps_closure_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_qf_many<span class="main">:</span> <span class="quoted"><span class="quoted">"run <span class="main">{</span><span class="free">qf</span><span class="main">}</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_Cons delta_qf run_empty <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_qf_many<span class="main">:</span> <span class="quoted"><span class="quoted">"run_accept <span class="main">{</span><span class="free">qf</span><span class="main">}</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span> <span class="free">cs</span> <span class="main">⟷</span> False"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.run_accept_def <span class="keyword1"><span class="command">using</span></span> run_qf_many accept_empty <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_qf_one<span class="main">:</span> <span class="quoted"><span class="quoted">"run_accept <span class="main">{</span><span class="free">qf</span><span class="main">}</span> <span class="main">[]</span> <span class="free">bs</span> <span class="main">⟷</span> True"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.run_accept_def NFA.accept_def <span class="keyword1"><span class="command">using</span></span> run_Nil eps_closure_set_refl <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> nfa_cong <span class="main">=</span> nfa <span class="quoted"><span class="free">q0</span></span> <span class="quoted"><span class="free">qf</span></span> <span class="quoted"><span class="free">transs</span></span> <span class="main">+</span> nfa'<span class="main">:</span> nfa <span class="quoted"><span class="free">q0'</span></span> <span class="quoted"><span class="free">qf'</span></span> <span class="quoted"><span class="free">transs'</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">q0</span> <span class="free">q0'</span> <span class="free">qf</span> <span class="free">qf'</span> <span class="free">transs</span> <span class="free">transs'</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SQ_sub<span class="main">:</span> <span class="quoted"><span class="quoted">"nfa'.SQ <span class="main">⊆</span> SQ"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  qf_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">qf</span> <span class="main">=</span> <span class="free">qf'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  transs_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> nfa'.SQ <span class="main">⟹</span> <span class="free">transs</span> <span class="main">!</span> <span class="main">(</span><span class="bound">q</span> <span class="main">-</span> <span class="free">q0</span><span class="main">)</span> <span class="main">=</span> <span class="free">transs'</span> <span class="main">!</span> <span class="main">(</span><span class="bound">q</span> <span class="main">-</span> <span class="free">q0'</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> q_Q_SQ_nfa'_SQ<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> nfa'.Q <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> SQ <span class="main">⟷</span> <span class="free">q</span> <span class="main">∈</span> nfa'.SQ"</span></span>
  <span class="keyword1"><span class="command">using</span></span> SQ_sub qf_not_in_SQ qf_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.Q_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> nfa'.Q <span class="main">⟹</span> step_eps <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟷</span> nfa'.step_eps <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> q_Q_SQ_nfa'_SQ transs_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.step_eps_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_nfa'_eps_closure<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> nfa'.Q <span class="main">⟹</span>
  <span class="free">q'</span> <span class="main">∈</span> nfa'.Q <span class="main">∧</span> nfa'.eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> nfa'.eps_closure_closed step_eps_cong <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.eps_closure_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> nfa'_eps_eps_closure<span class="main">:</span> <span class="quoted"><span class="quoted">"nfa'.eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> nfa'.Q <span class="main">⟹</span>
  <span class="free">q'</span> <span class="main">∈</span> nfa'.Q <span class="main">∧</span> eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> nfa'.step_eps_closed step_eps_cong
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.eps_closure_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtranclp.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q <span class="main">⟹</span> eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span>
  nfa'.eps_closure_set <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eps_nfa'_eps_closure nfa'_eps_eps_closure
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.eps_closure_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> nfa'.Q <span class="main">⟹</span> step_wild <span class="free">q</span> <span class="free">q'</span> <span class="main">⟷</span> nfa'.step_wild <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> q_Q_SQ_nfa'_SQ transs_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.step_wild_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q <span class="main">⟹</span> step_wild_set <span class="free">R</span> <span class="main">=</span> nfa'.step_wild_set <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> step_wild_cong <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.step_wild_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> delta_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q <span class="main">⟹</span> delta <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> nfa'.delta <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> step_wild_set_cong nfa'.eps_closure_set_closed
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.delta_def eps_closure_set_cong<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q <span class="main">⟹</span> run <span class="free">R</span> <span class="free">bss</span> <span class="main">=</span> nfa'.run <span class="free">R</span> <span class="free">bss</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.run_def
  <span class="keyword1"><span class="command">using</span></span> nfa'.delta_closed delta_cong <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">bss</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">R</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> accept_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q <span class="main">⟹</span> accept <span class="free">R</span> <span class="free">bs</span> <span class="main">⟷</span> nfa'.accept <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.accept_def <span class="keyword1"><span class="command">using</span></span> eps_closure_set_cong qf_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"run_accept <span class="free">R</span> <span class="free">bss</span> <span class="free">bs</span> <span class="main">⟷</span> nfa'.run_accept <span class="free">R</span> <span class="free">bss</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.run_accept_def run_cong<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
    accept_cong<span class="main">[</span><span class="operator">OF</span> nfa'.run_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">list_split</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> list <span class="main">×</span> <span class="tfree">'a</span> list<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list_split</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">list_split</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="bound">ys</span><span class="main">,</span> <span class="bound">zs</span><span class="main">)</span> <span class="main">∈</span> <span class="free">list_split</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="bound">ys</span><span class="main">,</span> <span class="bound">zs</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> list_split_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="bound">ys</span><span class="main">,</span> <span class="bound">zs</span><span class="main">)</span> <span class="main">∈</span> list_split <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">ys</span> <span class="bound">zs</span><span class="main">)</span> <span class="main">=</span>
  <span class="free">f</span> <span class="main">[]</span> <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="bound">ys</span><span class="main">,</span> <span class="bound">zs</span><span class="main">)</span> <span class="main">∈</span> list_split <span class="free">xs</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span> <span class="bound">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> list_split_def<span class="main">:</span> <span class="quoted"><span class="quoted">"list_split <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">n</span> <span class="main">&lt;</span> length <span class="free">xs</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span>take <span class="bound">n</span> <span class="free">xs</span><span class="main">,</span> drop <span class="bound">n</span> <span class="free">xs</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> less_Suc_eq_0_disj <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_split.induct<span class="main">)</span> <span class="operator">auto</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">locale</span></span> nfa_cong' <span class="main">=</span> nfa <span class="quoted"><span class="free">q0</span></span> <span class="quoted"><span class="free">qf</span></span> <span class="quoted"><span class="free">transs</span></span> <span class="main">+</span> nfa'<span class="main">:</span> nfa <span class="quoted"><span class="free">q0'</span></span> <span class="quoted"><span class="free">qf'</span></span> <span class="quoted"><span class="free">transs'</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">q0</span> <span class="free">q0'</span> <span class="free">qf</span> <span class="free">qf'</span> <span class="free">transs</span> <span class="free">transs'</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SQ_sub<span class="main">:</span> <span class="quoted"><span class="quoted">"nfa'.SQ <span class="main">⊆</span> SQ"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  qf'_in_SQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">qf'</span> <span class="main">∈</span> SQ"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  transs_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> nfa'.SQ <span class="main">⟹</span> <span class="free">transs</span> <span class="main">!</span> <span class="main">(</span><span class="bound">q</span> <span class="main">-</span> <span class="free">q0</span><span class="main">)</span> <span class="main">=</span> <span class="free">transs'</span> <span class="main">!</span> <span class="main">(</span><span class="bound">q</span> <span class="main">-</span> <span class="free">q0'</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nfa'_Q_sub_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"nfa'.Q <span class="main">⊆</span> Q"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.Q_def <span class="keyword1"><span class="command">using</span></span> SQ_sub qf'_in_SQ <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> q_SQ_SQ_nfa'_SQ<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> nfa'.SQ <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> SQ <span class="main">⟷</span> <span class="free">q</span> <span class="main">∈</span> nfa'.SQ"</span></span>
  <span class="keyword1"><span class="command">using</span></span> SQ_sub <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_cong_SQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> nfa'.SQ <span class="main">⟹</span> step_eps <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟷</span> nfa'.step_eps <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> q_SQ_SQ_nfa'_SQ transs_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.step_eps_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_eps_cong_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> nfa'.Q <span class="main">⟹</span> nfa'.step_eps <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> step_eps <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> SQ_sub transs_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.step_eps_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> nfa'_eps_closure_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"nfa'.eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> nfa'.Q <span class="main">⟹</span>
  eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> NFA.Q_def NFA.eps_closure_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtranclp.rtrancl_into_rtrancl step_eps_cong_SQ step_eps_dest<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> nfa'_eps_closure_set_sub<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q <span class="main">⟹</span> nfa'.eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">⊆</span>
  eps_closure_set <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_set_def
  <span class="keyword1"><span class="command">using</span></span> nfa'_eps_closure_cong <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_nfa'_eps_closure_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> nfa'.Q <span class="main">⟹</span>
  <span class="main">(</span><span class="free">q'</span> <span class="main">∈</span> nfa'.Q <span class="main">∧</span> nfa'.eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span><span class="main">)</span> <span class="main">∨</span>
  <span class="main">(</span>nfa'.eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">qf'</span> <span class="main">∧</span> eps_closure <span class="free">bs</span> <span class="free">qf'</span> <span class="free">q'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> nfa'.eps_closure_closed nfa'.step_eps_closed step_eps_cong_SQ NFA.Q_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtranclp.rtrancl_into_rtrancl<span class="main">)</span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nfa'_eps_eps_closure_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"nfa'.eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> nfa'.Q <span class="main">⟹</span>
  <span class="free">q'</span> <span class="main">∈</span> nfa'.Q <span class="main">∧</span> eps_closure <span class="free">bs</span> <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> nfa'.step_eps_closed step_eps_cong_Q
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtranclp.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_cong_reach<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q <span class="main">⟹</span> <span class="free">qf'</span> <span class="main">∈</span> nfa'.eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">⟹</span>
  eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> nfa'.eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">∪</span> eps_closure_set <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eps_nfa'_eps_closure_cong nfa'_eps_eps_closure_cong
    rtranclp_trans<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"step_eps <span class="free">bs</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_set_def NFA.eps_closure_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_cong_unreach<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q <span class="main">⟹</span> <span class="free">qf'</span> <span class="main">∉</span> nfa'.eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">⟹</span>
  eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> nfa'.eps_closure_set <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eps_nfa'_eps_closure_cong nfa'_eps_eps_closure_cong
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_set_def NFA.eps_closure_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_cong_SQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> nfa'.SQ <span class="main">⟹</span> step_wild <span class="free">q</span> <span class="free">q'</span> <span class="main">⟷</span> nfa'.step_wild <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> q_SQ_SQ_nfa'_SQ transs_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.step_wild_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_cong_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"nfa'.step_wild <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> step_wild <span class="free">q</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> SQ_sub transs_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.step_wild_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_cong_SQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.SQ <span class="main">⟹</span> step_wild_set <span class="free">R</span> <span class="main">=</span> nfa'.step_wild_set <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> step_wild_cong_SQ <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.step_wild_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_cong_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"nfa'.step_wild_set <span class="free">R</span> <span class="main">⊆</span> step_wild_set <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> step_wild_cong_Q <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFA.step_wild_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> delta_cong_unreach<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>nfa'.accept <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"delta <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> nfa'.delta <span class="free">R</span> <span class="free">bs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nfa'.eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">⊆</span> nfa'.SQ"</span></span>
    <span class="keyword1"><span class="command">using</span></span> nfa'.eps_closure_set_closed<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">unfolded</span> NFA.Q_def<span class="main">]</span>
      assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> NFA.accept_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> NFA.accept_def NFA.delta_def <span class="keyword1"><span class="command">using</span></span> step_wild_set_cong_SQ
      eps_closure_set_cong_unreach<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> NFA.accept_def<span class="main"><span class="main">]</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nfa'_delta_sub_delta<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nfa'.delta <span class="free">R</span> <span class="free">bs</span> <span class="main">⊆</span> delta <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.delta_def
  <span class="keyword1"><span class="command">using</span></span> step_wild_set_mono<span class="main">[</span><span class="operator">OF</span> nfa'_eps_closure_set_sub<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">]</span> step_wild_set_cong_Q
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span> delta_cong_reach<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q"</span></span> <span class="quoted"><span class="quoted">"nfa'.accept <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"delta <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span> nfa'.delta <span class="free">R</span> <span class="free">bs</span> <span class="main">∪</span> delta <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="free">bs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> set_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">q</span>
  <span class="keyword3"><span class="command">assume</span></span> assm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> delta <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> nfa'_eps_diff_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"nfa'.eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">=</span>
    nfa'.eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">-</span> <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="free">qf'</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> NFA.accept_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> assm <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> step_wild_set <span class="main">(</span>nfa'.eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">-</span> <span class="main">{</span><span class="free">qf'</span><span class="main">}</span><span class="main">)</span> <span class="main">∪</span>
    step_wild_set <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="main">∪</span> delta <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="free">bs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> NFA.delta_def eps_closure_set_cong_reach<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
      assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> NFA.accept_def<span class="main"><span class="main">]</span></span><span class="main">]</span> step_wild_set_split<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      nfa'_eps_diff_Un<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> step_wild_set <span class="main">(</span>nfa'.eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">-</span> <span class="main">{</span><span class="free">qf'</span><span class="main">}</span><span class="main">)</span> <span class="main">∪</span> delta <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="free">bs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> step_wild_set_mono<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">qf'</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="free">bs</span>"</span></span><span class="main">,</span>
      <span class="operator">OF</span> eps_closure_set_refl<span class="main">,</span> <span class="operator">unfolded</span> NFA.delta_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
    delta_step_wild_set_absorb <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> nfa'.delta <span class="free">R</span> <span class="free">bs</span> <span class="main">∪</span> delta <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="free">bs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> NFA.delta_def
    <span class="keyword1"><span class="command">using</span></span> nfa'.eps_closure_set_closed<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">unfolded</span> NFA.Q_def<span class="main">]</span>
      step_wild_set_cong_SQ<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"nfa'.eps_closure_set <span class="free">R</span> <span class="free">bs</span> <span class="main">-</span> <span class="main">{</span><span class="free">qf'</span><span class="main">}</span>"</span></span><span class="main">]</span>
      step_wild_set_mono <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">q</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> nfa'.delta <span class="free">R</span> <span class="free">bs</span> <span class="main">∪</span> delta <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> delta <span class="free">R</span> <span class="free">bs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> nfa'_delta_sub_delta<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> delta_sub_eps_mono<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">qf'</span><span class="main">}</span>"</span></span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="free">R</span></span> <span class="quoted"><span class="free">bs</span></span><span class="main">]</span>
      assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> NFA.accept_def<span class="main">]</span> nfa'_eps_closure_set_sub<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> run_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"run <span class="free">R</span> <span class="free">bss</span> <span class="main">=</span> nfa'.run <span class="free">R</span> <span class="free">bss</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="bound">css</span><span class="main">,</span> <span class="bound">css'</span><span class="main">)</span> <span class="main">∈</span> list_split <span class="free">bss</span><span class="main">.</span>
    <span class="keyword1">if</span> nfa'.run_accept <span class="free">R</span> <span class="bound">css</span> <span class="main">(</span>hd <span class="bound">css'</span><span class="main">)</span> <span class="keyword1">then</span> run <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="bound">css'</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">bss</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">R</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_split.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> run_Nil <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"nfa'.accept <span class="skolem">R</span> <span class="skolem">x</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> run_Cons delta_cong_reach<span class="main">[</span><span class="operator">OF</span> 2<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
      delta_cong_unreach<span class="main">[</span><span class="operator">OF</span> 2<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> run_split run_accept_Nil run_accept_Cons
      list_split_unfold<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">ys</span> <span class="bound">zs</span><span class="main">.</span> <span class="keyword1">if</span> nfa'.run_accept <span class="skolem">R</span> <span class="bound">ys</span> <span class="main">(</span>hd <span class="bound">zs</span><span class="main">)</span>
      <span class="keyword1">then</span> run <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="bound">zs</span> <span class="keyword1">else</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">using</span></span> 2<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"nfa'.delta <span class="skolem">R</span> <span class="skolem">x</span>"</span></span><span class="main">,</span>
    <span class="operator">OF</span> nfa'.delta_closed<span class="main">,</span> <span class="operator">unfolded</span> run_accept_Nil<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> run_cong_Cons_sub<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q"</span></span> <span class="quoted"><span class="quoted">"delta <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="free">bs</span> <span class="main">⊆</span> nfa'.delta <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"run <span class="free">R</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span> <span class="main">=</span> nfa'.run <span class="free">R</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span> <span class="main">∪</span>
    <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="bound">css</span><span class="main">,</span> <span class="bound">css'</span><span class="main">)</span> <span class="main">∈</span> list_split <span class="free">bss</span><span class="main">.</span>
    <span class="keyword1">if</span> nfa'.run_accept <span class="main">(</span>nfa'.delta <span class="free">R</span> <span class="free">bs</span><span class="main">)</span> <span class="bound">css</span> <span class="main">(</span>hd <span class="bound">css'</span><span class="main">)</span> <span class="keyword1">then</span> run <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="bound">css'</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> run_Cons <span class="keyword1"><span class="command">using</span></span> run_cong<span class="main">[</span><span class="operator">OF</span> nfa'.delta_closed<span class="main">]</span>
    delta_cong_reach<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> delta_cong_unreach<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"nfa'.accept <span class="free">R</span> <span class="free">bs</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Un_absorb2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> accept_nfa'_run<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"accept <span class="main">(</span>nfa'.run <span class="free">R</span> <span class="free">bss</span><span class="main">)</span> <span class="free">bs</span> <span class="main">⟷</span>
    nfa'.accept <span class="main">(</span>nfa'.run <span class="free">R</span> <span class="free">bss</span><span class="main">)</span> <span class="free">bs</span> <span class="main">∧</span> accept <span class="main">(</span>run <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="main">[]</span><span class="main">)</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.accept_def run_Nil
  <span class="keyword1"><span class="command">using</span></span> eps_closure_set_cong_reach<span class="main">[</span><span class="operator">OF</span> nfa'.run_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">]</span>
    eps_closure_set_cong_unreach<span class="main">[</span><span class="operator">OF</span> nfa'.run_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">]</span> qf_not_in_SQ
    qf'_in_SQ nfa'.eps_closure_set_closed<span class="main">[</span><span class="operator">OF</span> nfa'.run_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">,</span>
    <span class="operator">unfolded</span> NFA.Q_def<span class="main">]</span> SQ_sub
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">qf'</span> <span class="main">∈</span> nfa'.eps_closure_set <span class="main">(</span>nfa'.run <span class="free">R</span> <span class="free">bss</span><span class="main">)</span> <span class="free">bs</span>"</span></span><span class="main">)</span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"run_accept <span class="free">R</span> <span class="free">bss</span> <span class="free">bs</span> <span class="main">⟷</span> <span class="main">(</span>nfa'.run_accept <span class="free">R</span> <span class="free">bss</span> <span class="free">bs</span> <span class="main">∧</span> run_accept <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="main">[]</span> <span class="free">bs</span><span class="main">)</span> <span class="main">∨</span>
    <span class="main">(</span><span class="main">∃</span><span class="main">(</span><span class="bound">css</span><span class="main">,</span> <span class="bound">css'</span><span class="main">)</span> <span class="main">∈</span> list_split <span class="free">bss</span><span class="main">.</span> nfa'.run_accept <span class="free">R</span> <span class="bound">css</span> <span class="main">(</span>hd <span class="bound">css'</span><span class="main">)</span> <span class="main">∧</span>
    run_accept <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="bound">css'</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.run_accept_def run_cong<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> accept_split
    accept_Un accept_nfa'_run<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> accept_empty <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_cong_Cons_sub<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> nfa'.Q"</span></span> <span class="quoted"><span class="quoted">"delta <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="free">bs</span> <span class="main">⊆</span> nfa'.delta <span class="free">R</span> <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"run_accept <span class="free">R</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span> <span class="free">cs</span> <span class="main">⟷</span>
    <span class="main">(</span>nfa'.run_accept <span class="free">R</span> <span class="main">(</span><span class="free">bs</span> <span class="main">#</span> <span class="free">bss</span><span class="main">)</span> <span class="free">cs</span> <span class="main">∧</span> run_accept <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="main">[]</span> <span class="free">cs</span><span class="main">)</span> <span class="main">∨</span>
    <span class="main">(</span><span class="main">∃</span><span class="main">(</span><span class="bound">css</span><span class="main">,</span> <span class="bound">css'</span><span class="main">)</span> <span class="main">∈</span> list_split <span class="free">bss</span><span class="main">.</span> nfa'.run_accept <span class="main">(</span>nfa'.delta <span class="free">R</span> <span class="free">bs</span><span class="main">)</span> <span class="bound">css</span> <span class="main">(</span>hd <span class="bound">css'</span><span class="main">)</span> <span class="main">∧</span>
    run_accept <span class="main">{</span><span class="free">qf'</span><span class="main">}</span> <span class="bound">css'</span> <span class="free">cs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.run_accept_def run_cong_Cons_sub<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
    accept_split accept_Un accept_nfa'_run<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> accept_empty <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> run_accept_cong_Cons_sub_simp <span class="main">=</span>
  run_accept_cong_Cons_sub<span class="main">[</span><span class="operator">unfolded</span> list_split_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span>
    <span class="operator">unfolded</span> run_accept_Cons<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> take_Suc_Cons<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> nfa_cong_Plus <span class="main">=</span> nfa_cong <span class="quoted"><span class="free">q0</span></span> <span class="quoted"><span class="free">q0'</span></span> <span class="quoted"><span class="free">qf</span></span> <span class="quoted"><span class="free">qf'</span></span> <span class="quoted"><span class="free">transs</span></span> <span class="quoted"><span class="free">transs'</span></span> <span class="main">+</span>
  right<span class="main">:</span> nfa_cong <span class="quoted"><span class="free">q0</span></span> <span class="quoted"><span class="free">q0''</span></span> <span class="quoted"><span class="free">qf</span></span> <span class="quoted"><span class="free">qf''</span></span> <span class="quoted"><span class="free">transs</span></span> <span class="quoted"><span class="free">transs''</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">q0</span> <span class="free">q0'</span> <span class="free">q0''</span> <span class="free">qf</span> <span class="free">qf'</span> <span class="free">qf''</span> <span class="free">transs</span> <span class="free">transs'</span> <span class="free">transs''</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> step_eps_q0<span class="main">:</span> <span class="quoted"><span class="quoted">"step_eps <span class="free">bs</span> <span class="free">q0</span> <span class="free">q</span> <span class="main">⟷</span> <span class="free">q</span> <span class="main">∈</span> <span class="main">{</span><span class="free">q0'</span><span class="main">,</span> <span class="free">q0''</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  step_wild_q0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>step_wild <span class="free">q0</span> <span class="free">q</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_q0<span class="main">:</span> <span class="quoted"><span class="quoted">"step_wild_set <span class="main">{</span><span class="free">q0</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.step_wild_set_def <span class="keyword1"><span class="command">using</span></span> step_wild_q0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> qf_not_q0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">qf</span> <span class="main">∉</span> <span class="main">{</span><span class="free">q0</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> qf_not_in_SQ q0_sub_SQ <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_q0<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="main">{</span><span class="free">q0</span><span class="main">}</span> <span class="free">bs</span> <span class="main">=</span> <span class="main">{</span><span class="free">q0</span><span class="main">}</span> <span class="main">∪</span>
  <span class="main">(</span>nfa'.eps_closure_set <span class="main">{</span><span class="free">q0'</span><span class="main">}</span> <span class="free">bs</span> <span class="main">∪</span> right.nfa'.eps_closure_set <span class="main">{</span><span class="free">q0''</span><span class="main">}</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eps_closure_set_unfold<span class="main">[</span><span class="operator">OF</span> step_eps_q0<span class="main">]</span>
    insert_is_Un<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">q0'</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">q0''</span><span class="main">}</span>"</span></span><span class="main">]</span>
    eps_closure_set_split<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">q0'</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">q0''</span><span class="main">}</span>"</span></span><span class="main">]</span>
    eps_closure_set_cong<span class="main">[</span><span class="operator">OF</span> nfa'.q0_sub_Q<span class="main">]</span>
    right.eps_closure_set_cong<span class="main">[</span><span class="operator">OF</span> right.nfa'.q0_sub_Q<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> run_accept_Nil_cong <span class="main">=</span>
  run_accept_Nil_eps_split<span class="main">[</span><span class="operator">OF</span> eps_closure_set_q0 step_wild_set_q0 qf_not_q0<span class="main">,</span>
    <span class="operator">unfolded</span> run_accept_split
    run_accept_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nfa'.eps_closure_set_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nfa'.q0_sub_Q<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span>
    right.run_accept_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> right.nfa'.eps_closure_set_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> right.nfa'.q0_sub_Q<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span>
    run_accept_Nil_eps<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> run_accept_Cons_cong <span class="main">=</span>
  run_accept_Cons_eps_split<span class="main">[</span><span class="operator">OF</span> eps_closure_set_q0 step_wild_set_q0 qf_not_q0<span class="main">,</span>
    <span class="operator">unfolded</span> run_accept_split
    run_accept_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nfa'.eps_closure_set_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nfa'.q0_sub_Q<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span>
    right.run_accept_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> right.nfa'.eps_closure_set_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> right.nfa'.q0_sub_Q<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span>
    run_accept_Cons_eps<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"run_accept <span class="main">{</span><span class="free">q0</span><span class="main">}</span> <span class="free">bss</span> <span class="free">bs</span> <span class="main">⟷</span>
  <span class="main">(</span>nfa'.run_accept <span class="main">{</span><span class="free">q0'</span><span class="main">}</span> <span class="free">bss</span> <span class="free">bs</span> <span class="main">∨</span> right.nfa'.run_accept <span class="main">{</span><span class="free">q0''</span><span class="main">}</span> <span class="free">bss</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> run_accept_Nil_cong run_accept_Cons_cong <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">bss</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> nfa_cong_Times <span class="main">=</span> nfa_cong' <span class="quoted"><span class="free">q0</span></span> <span class="quoted"><span class="free">q0</span></span> <span class="quoted"><span class="free">qf</span></span> <span class="quoted"><span class="free">q0'</span></span> <span class="quoted"><span class="free">transs</span></span> <span class="quoted"><span class="free">transs'</span></span> <span class="main">+</span>
  right<span class="main">:</span> nfa_cong <span class="quoted"><span class="free">q0</span></span> <span class="quoted"><span class="free">q0'</span></span> <span class="quoted"><span class="free">qf</span></span> <span class="quoted"><span class="free">qf</span></span> <span class="quoted"><span class="free">transs</span></span> <span class="quoted"><span class="free">transs''</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">q0</span> <span class="free">q0'</span> <span class="free">qf</span> <span class="free">transs</span> <span class="free">transs'</span> <span class="free">transs''</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> run_accept_cong <span class="main">=</span>
  run_accept_cong<span class="main">[</span><span class="operator">OF</span> nfa'.q0_sub_Q<span class="main">,</span> <span class="operator">unfolded</span>
    right.run_accept_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> right.nfa'.q0_sub_Q<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">unfolded</span> list_split_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> nfa_cong_Star <span class="main">=</span> nfa_cong' <span class="quoted"><span class="free">q0</span></span> <span class="quoted"><span class="free">q0'</span></span> <span class="quoted"><span class="free">qf</span></span> <span class="quoted"><span class="free">q0</span></span> <span class="quoted"><span class="free">transs</span></span> <span class="quoted"><span class="free">transs'</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">q0</span> <span class="free">q0'</span> <span class="free">qf</span> <span class="free">transs</span> <span class="free">transs'</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> step_eps_q0<span class="main">:</span> <span class="quoted"><span class="quoted">"step_eps <span class="free">bs</span> <span class="free">q0</span> <span class="free">q</span> <span class="main">⟷</span> <span class="free">q</span> <span class="main">∈</span> <span class="main">{</span><span class="free">q0'</span><span class="main">,</span> <span class="free">qf</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  step_wild_q0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>step_wild <span class="free">q0</span> <span class="free">q</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> step_wild_set_q0<span class="main">:</span> <span class="quoted"><span class="quoted">"step_wild_set <span class="main">{</span><span class="free">q0</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.step_wild_set_def <span class="keyword1"><span class="command">using</span></span> step_wild_q0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> run_accept_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"run_accept <span class="main">{</span><span class="free">q0</span><span class="main">}</span> <span class="main">[]</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.run_accept_def NFA.run_def <span class="keyword1"><span class="command">using</span></span> step_eps_accept step_eps_q0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span> rtranclp_step_eps_q0_q0'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>step_eps <span class="free">bs</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">q</span> <span class="free">q'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">=</span> <span class="free">q0</span> <span class="main">⟹</span>
  <span class="free">q'</span> <span class="main">∈</span> <span class="main">{</span><span class="free">q0</span><span class="main">,</span> <span class="free">qf</span><span class="main">}</span> <span class="main">∨</span> <span class="main">(</span><span class="free">q'</span> <span class="main">∈</span> nfa'.SQ <span class="main">∧</span> <span class="main">(</span>nfa'.step_eps <span class="free">bs</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">q0'</span> <span class="free">q'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> step_eps_q0 step_eps_dest qf_not_in_SQ step_eps_cong_SQ nfa'.q0_sub_SQ
    nfa'.step_eps_closed<span class="main">[</span><span class="operator">unfolded</span> NFA.Q_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_q0<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="main">{</span><span class="free">q0</span><span class="main">}</span> <span class="free">bs</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">q0</span><span class="main">,</span> <span class="free">qf</span><span class="main">}</span> <span class="main">∪</span>
  <span class="main">(</span>nfa'.eps_closure_set <span class="main">{</span><span class="free">q0'</span><span class="main">}</span> <span class="free">bs</span> <span class="main">∩</span> nfa'.SQ<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_set_def NFA.eps_closure_def
  <span class="keyword1"><span class="command">using</span></span> rtranclp_step_eps_q0_q0' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> delta_sub_nfa'_delta<span class="main">:</span> <span class="quoted"><span class="quoted">"delta <span class="main">{</span><span class="free">q0</span><span class="main">}</span> <span class="free">bs</span> <span class="main">⊆</span> nfa'.delta <span class="main">{</span><span class="free">q0'</span><span class="main">}</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.delta_def
  <span class="keyword1"><span class="command">using</span></span> step_wild_set_mono<span class="main">[</span><span class="operator">OF</span> eps_closure_set_q0<span class="main">,</span> <span class="operator">unfolded</span> step_wild_set_q0
    step_wild_set_qf step_wild_set_split insert_is_Un<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">q0</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">qf</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
    step_wild_set_cong_SQ
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> boolean_algebra_cancel.sup0 inf_le2 step_wild_set_proj step_wild_set_q0
      step_wild_set_qf sup_commute<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eps_closure_set_q0_split<span class="main">:</span> <span class="quoted"><span class="quoted">"eps_closure_set <span class="main">{</span><span class="free">q0</span><span class="main">}</span> <span class="free">bs</span> <span class="main">=</span> <span class="main">{</span><span class="free">q0</span><span class="main">,</span> <span class="free">qf</span><span class="main">}</span> <span class="main">∪</span>
  eps_closure_set <span class="main">{</span><span class="free">q0'</span><span class="main">}</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.eps_closure_set_def NFA.eps_closure_def
  <span class="keyword1"><span class="command">using</span></span> step_eps_qf step_eps_q0
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> rtranclp_unfold<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> r_into_rtranclp rtranclp.rtrancl_into_rtrancl rtranclp_idemp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> delta_q0_q0'<span class="main">:</span> <span class="quoted"><span class="quoted">"delta <span class="main">{</span><span class="free">q0</span><span class="main">}</span> <span class="free">bs</span> <span class="main">=</span> delta <span class="main">{</span><span class="free">q0'</span><span class="main">}</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.delta_def eps_closure_set_q0_split step_wild_set_split
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.delta_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> NFA.step_wild_set_def
  <span class="keyword1"><span class="command">using</span></span> step_wild_q0 step_wild_dest qf_not_in_SQ
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemmas</span></span> run_accept_cong_Cons <span class="main">=</span>
  run_accept_cong_Cons_sub_simp<span class="main">[</span><span class="operator">OF</span> nfa'.q0_sub_Q delta_sub_nfa'_delta<span class="main">,</span>
    <span class="operator">unfolded</span> run_accept_Cons_delta_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> delta_q0_q0'<span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</body>

</html>